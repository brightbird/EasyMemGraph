import os
import json
import logging
from datetime import datetime
from typing import Dict, List, Any, Tuple
import streamlit as st
from streamlit_chat import message

# Local imports
from memory_agent import conversation_graph, search_memories, store_interaction
from config import Config

# Additional imports for user management
try:
    from qdrant_client import QdrantClient
    from qdrant_client.models import Filter, FieldCondition, MatchAny, models
    QDRANT_AVAILABLE = True
except ImportError:
    QDRANT_AVAILABLE = False
    logger.warning("Qdrant client not available, user scanning functionality disabled")

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Configure Streamlit page
st.set_page_config(
    page_title="ÂøÜËØ≠ (YiYu) - Êô∫ËÉΩÂØπËØùÔºåËÆ∞ÂøÜÊ∞∏Â≠ò",
    page_icon="üß†üí¨",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for YiYu branding
st.markdown("""
<style>
    .chat-message {
        padding: 1rem;
        border-radius: 0.5rem;
        margin-bottom: 1rem;
        display: flex;
        flex-direction: column;
    }

    .user-message {
        background: linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%);
        align-items: flex-end;
        border-left: 4px solid #2196F3;
    }

    .assistant-message {
        background: linear-gradient(135deg, #F3E5F5 0%, #E1BEE7 100%);
        align-items: flex-start;
        border-left: 4px solid #9C27B0;
    }

    .memory-ref {
        background: linear-gradient(135deg, #FFF3E0 0%, #FFE0B2 100%);
        padding: 0.75rem;
        border-radius: 0.5rem;
        margin-top: 0.75rem;
        border-left: 4px solid #FF6F00;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .session-item {
        padding: 0.75rem;
        margin: 0.25rem 0;
        border-radius: 0.5rem;
        cursor: pointer;
        transition: all 0.3s ease;
        border: 1px solid #E0E0E0;
    }

    .session-item:hover {
        background: linear-gradient(135deg, #F5F5F5 0%, #EEEEEE 100%);
        border-color: #9C27B0;
        transform: translateY(-1px);
    }

    .active-session {
        background: linear-gradient(135deg, #E8F5E8 0%, #C8E6C9 100%);
        border-left: 4px solid #4CAF50;
        border-color: #4CAF50;
    }

    /* YiYu branding elements */
    .yiyu-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1rem;
        border-radius: 0.5rem;
        margin-bottom: 1rem;
    }

    .yiyu-button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 0.25rem;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .yiyu-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
    }
</style>
""", unsafe_allow_html=True)

def get_user_statistics(user_id: str) -> Dict[str, Any]:
    """
    Get detailed statistics for a specific user.
    Returns information like memory count, last activity, etc.
    """
    try:
        # Get memory statistics
        memories = search_memories("", user_id, limit=100)  # Get up to 100 memories
        memory_count = len(memories.get('results', [])) if memories else 0

        # Try to get more detailed information from Qdrant
        last_activity = None
        conversation_count = 0

        if QDRANT_AVAILABLE:
            try:
                qdrant_config = Config.get_qdrant_config()
                qdrant_url = qdrant_config["config"]["url"]
                collection_name = qdrant_config["config"]["collection_name"]
                api_key = qdrant_config["config"]["api_key"]

                if api_key:
                    client = QdrantClient(url=qdrant_url, api_key=api_key)
                else:
                    client = QdrantClient(url=qdrant_url)

                # Search for user-specific records with timestamp information
                from qdrant_client.models import Filter, FieldCondition

                # Try to find records for this user
                user_filter = Filter(
                    must=[
                        FieldCondition(
                            key="user_id",
                            match={"value": user_id}
                        )
                    ]
                )

                # Get some records to estimate activity
                try:
                    records, _ = client.scroll(
                        collection_name=collection_name,
                        scroll_filter=user_filter,
                        limit=50,
                        with_payload=True
                    )

                    if records:
                        conversation_count = len(records)
                        # Extract timestamp information if available
                        timestamps = []
                        for record in records:
                            if record.payload:
                                # Look for timestamp in various possible locations
                                timestamp = None
                                if 'timestamp' in record.payload:
                                    timestamp = record.payload['timestamp']
                                elif 'metadata' in record.payload and 'timestamp' in record.payload['metadata']:
                                    timestamp = record.payload['metadata']['timestamp']
                                elif 'created_at' in record.payload:
                                    timestamp = record.payload['created_at']

                                if timestamp:
                                    timestamps.append(timestamp)

                        if timestamps:
                            # Get the most recent timestamp
                            last_activity = max(timestamps)

                except Exception as e:
                    logger.debug(f"Could not get detailed stats for user {user_id}: {e}")

            except Exception as e:
                logger.debug(f"Qdrant not available for user stats: {e}")

        return {
            'user_id': user_id,
            'memory_count': memory_count,
            'conversation_count': conversation_count,
            'last_activity': last_activity,
            'has_data': memory_count > 0 or conversation_count > 0
        }

    except Exception as e:
        logger.error(f"Error getting user statistics for {user_id}: {e}")
        return {
            'user_id': user_id,
            'memory_count': 0,
            'conversation_count': 0,
            'last_activity': None,
            'has_data': False
        }

def scan_existing_users() -> set:
    """
    Scan Qdrant vector database to find existing user IDs.
    Returns a set of unique user IDs found in the database.
    """
    if not QDRANT_AVAILABLE:
        logger.warning("Qdrant client not available, cannot scan existing users")
        return set()

    try:
        # Get Qdrant configuration
        qdrant_config = Config.get_qdrant_config()
        qdrant_url = qdrant_config["config"]["url"]
        collection_name = qdrant_config["config"]["collection_name"]
        api_key = qdrant_config["config"]["api_key"]

        # Initialize Qdrant client
        if api_key:
            client = QdrantClient(url=qdrant_url, api_key=api_key)
        else:
            client = QdrantClient(url=qdrant_url)

        # Check if collection exists
        try:
            collections = client.get_collections().collections
            collection_exists = any(collection.name == collection_name for collection in collections)
            if not collection_exists:
                logger.info(f"Collection '{collection_name}' does not exist, no existing users")
                return set()
        except Exception as e:
            logger.warning(f"Could not verify collection existence: {e}")
            return set()

        # Scroll through all points to extract user IDs
        logger.info(f"Scanning existing users from collection '{collection_name}'")

        all_users = set()
        offset = None
        limit = 100  # Process in batches

        while True:
            try:
                # Scroll through records
                records, next_page_offset = client.scroll(
                    collection_name=collection_name,
                    offset=offset,
                    limit=limit,
                    with_payload=True
                )

                # Extract user IDs from payloads
                for record in records:
                    if record.payload:
                        # Look for user_id in different possible payload structures
                        user_id = None

                        # Check direct user_id field
                        if 'user_id' in record.payload:
                            user_id = record.payload['user_id']

                        # Check nested structure (Mem0 might store it this way)
                        elif 'metadata' in record.payload and 'user_id' in record.payload['metadata']:
                            user_id = record.payload['metadata']['user_id']

                        # Check if user_id is in the payload as a string
                        if user_id and isinstance(user_id, str) and user_id.strip():
                            all_users.add(user_id.strip())

                # Check if there are more records
                if next_page_offset is None:
                    break

                offset = next_page_offset

            except Exception as e:
                logger.error(f"Error scanning batch of users: {e}")
                break

        logger.info(f"Found {len(all_users)} existing users in database")
        return all_users

    except Exception as e:
        logger.error(f"Failed to scan existing users from Qdrant: {e}")
        return set()

def init_session_state():
    """Initialize Streamlit session state variables."""
    if 'sessions' not in st.session_state:
        st.session_state.sessions = {}
    if 'current_session_id' not in st.session_state:
        st.session_state.current_session_id = None
    if 'user_id' not in st.session_state:
        st.session_state.user_id = "web_user"
    if 'show_memory_details' not in st.session_state:
        st.session_state.show_memory_details = {}
    if 'first_visit' not in st.session_state:
        st.session_state.first_visit = True
    if 'api_status' not in st.session_state:
        st.session_state.api_status = "unknown"
    if 'last_api_check' not in st.session_state:
        st.session_state.last_api_check = 0
    if 'user_history' not in st.session_state:
        st.session_state.user_history = set()
        # Load existing users from database on first initialization
        if 'existing_users_loaded' not in st.session_state:
            existing_users = scan_existing_users()
            st.session_state.user_history.update(existing_users)
            st.session_state.existing_users_loaded = True
            logger.info(f"Loaded {len(existing_users)} existing users from database")

        # Initialize with current user
        if st.session_state.user_id and st.session_state.user_id != "web_user":
            st.session_state.user_history.add(st.session_state.user_id)
    if 'ai_thinking' not in st.session_state:
        st.session_state.ai_thinking = False
    if 'pending_response' not in st.session_state:
        st.session_state.pending_response = None
    if 'show_suggestions' not in st.session_state:
        st.session_state.show_suggestions = True
    if 'selected_suggestion' not in st.session_state:
        st.session_state.selected_suggestion = None
    if 'suggestion_source' not in st.session_state:
        st.session_state.suggestion_source = None

    # Auto-create default session if no sessions exist
    if not st.session_state.sessions:
        create_new_session("ÈªòËÆ§ÂØπËØù")
        st.session_state.first_visit = True

def create_new_session(session_name: str = None) -> str:
    """Create a new conversation session."""
    if session_name is None:
        session_name = f"‰ºöËØù {datetime.now().strftime('%Y-%m-%d %H:%M')}"

    session_id = f"session_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

    st.session_state.sessions[session_id] = {
        'name': session_name,
        'messages': [],
        'created_at': datetime.now().isoformat(),
        'last_updated': datetime.now().isoformat()
    }

    st.session_state.current_session_id = session_id
    logger.info(f"Created new session: {session_id}")
    return session_id

def delete_session(session_id: str):
    """Delete a conversation session."""
    if session_id in st.session_state.sessions:
        del st.session_state.sessions[session_id]
        if st.session_state.current_session_id == session_id:
            st.session_state.current_session_id = None
        logger.info(f"Deleted session: {session_id}")

def switch_session(session_id: str):
    """Switch to a different conversation session."""
    if session_id in st.session_state.sessions:
        st.session_state.current_session_id = session_id
        st.session_state.sessions[session_id]['last_updated'] = datetime.now().isoformat()
        logger.info(f"Switched to session: {session_id}")

def add_message_to_session(session_id: str, role: str, content: str, memories: List[Dict] = None):
    """Add a message to the current session."""
    if session_id not in st.session_state.sessions:
        return

    message_data = {
        'role': role,
        'content': content,
        'timestamp': datetime.now().isoformat(),
        'memories': memories or []
    }

    st.session_state.sessions[session_id]['messages'].append(message_data)
    st.session_state.sessions[session_id]['last_updated'] = datetime.now().isoformat()

def get_conversation_response(user_input: str, user_id: str) -> Tuple[str, List[Dict]]:
    """Get response from the conversation agent with retry mechanism."""
    import time

    # Import here to avoid circular imports
    from langchain_core.messages import HumanMessage, AIMessage, SystemMessage

    max_retries = 3
    retry_delay = 2  # seconds

    for attempt in range(max_retries):
        try:
            # Search for relevant memories
            memories = search_memories(user_input, user_id, limit=5)
            memory_list = memories.get('results', []) if memories else []

            # Extract memory context
            memory_context = ""
            if memory_list:
                memory_context = "Relevant information from previous conversations:\n"
                for i, mem in enumerate(memory_list, 1):
                    memory_context += f"{i}. {mem.get('memory', '')}\n"

            # Create system message with memory context
            system_content = """‰Ω†ÊòØÂøÜËØ≠ (YiYu)Ôºå‰∏Ä‰∏™ÂÖ∑ÊúâËÆ∞ÂøÜÂäüËÉΩÁöÑÊô∫ËÉΩÂØπËØù‰ºô‰º¥„ÄÇËØ∑Ê†πÊçÆÊèê‰æõÁöÑ‰∏ä‰∏ãÊñá‰ø°ÊÅØÔºå‰∏∫Áî®Êà∑Êèê‰æõ‰∏™ÊÄßÂåñÁöÑÂõûÂ∫î„ÄÇ

            ÊåáÂØºÂéüÂàôÔºö
            1. Âà©Áî®ËÆ∞ÂøÜ‰∏≠ÁöÑ‰ø°ÊÅØÊèê‰æõËøûË¥ØÁöÑÂØπËØù‰ΩìÈ™å
            2. ËÆ∞‰ΩèÁî®Êà∑ÁöÑÂÅèÂ•ΩÂíåËøáÂéªÁöÑ‰∫§‰∫í
            3. ‰øùÊåÅÂèãÂ•ΩÂíå‰∏ì‰∏öÁöÑËØ≠Ë∞É
            4. Â¶ÇÊûúÊ≤°ÊúâÁõ∏ÂÖ≥ËÆ∞ÂøÜÔºåÂ∞±Âü∫‰∫éÂΩìÂâçÈóÆÈ¢òËøõË°åÂõûÁ≠î
            5. Áî®‰∏≠ÊñáÂõûÁ≠î

            """ + memory_context

            # Get response from conversation graph
            config = {"configurable": {"thread_id": user_id}}
            state = {
                "messages": [HumanMessage(content=user_input)],
                "mem0_user_id": user_id
            }

            response_content = ""
            for event in conversation_graph.stream(state, config):
                for value in event.values():
                    if value.get("messages"):
                        response_content = value["messages"][-1].content
                        break

            # Store the interaction in memory
            interaction = [
                {
                    "role": "user",
                    "content": user_input
                },
                {
                    "role": "assistant",
                    "content": response_content
                }
            ]

            store_interaction(interaction, user_id)

            # Update API status on success
            st.session_state.api_status = "normal"
            st.session_state.last_api_check = time.time()

            return response_content, memory_list

        except Exception as e:
            logger.error(f"Error getting conversation response (attempt {attempt + 1}/{max_retries}): {e}")
            error_str = str(e).lower()

            # For rate limiting, wait and retry
            if "429" in error_str or "rate limit" in error_str or "request limit exceeded" in error_str:
                st.session_state.api_status = "rate_limited"
                if attempt < max_retries - 1:
                    logger.info(f"Rate limit hit, waiting {retry_delay} seconds before retry...")
                    time.sleep(retry_delay)
                    retry_delay *= 2  # Exponential backoff
                    continue
                else:
                    return """üö´ **APIË∞ÉÁî®È¢ëÁéáÈôêÂà∂**

ÂæàÊä±Ê≠âÔºåÂΩìÂâçAPIË∞ÉÁî®È¢ëÁéáËøáÈ´òÔºåÂ∑≤ËææÂà∞‰ΩøÁî®ÈôêÂà∂„ÄÇËØ∑Á®çÂêéÂÜçËØï„ÄÇ

**Âª∫ËÆÆËß£ÂÜ≥ÊñπÊ°àÔºö**
1. Á≠âÂæÖ2-3ÂàÜÈíüÂêéÈáçËØï
2. Ê£ÄÊü•ÊÇ®ÁöÑModelScope APIÈÖçÈ¢ù
3. Â¶ÇÈúÄÊõ¥È´òÈÖçÈ¢ùÔºåËØ∑ËÅîÁ≥ªModelScopeÂçáÁ∫ßÊúçÂä°

Êàë‰ªçÁÑ∂ËÆ∞ÂæóÊàë‰ª¨‰πãÂâçÁöÑÂØπËØùÂÜÖÂÆπÔºåÁ®çÂêéÊÇ®ÂèØ‰ª•ÁªßÁª≠Êàë‰ª¨ÁöÑ‰∫§ÊµÅ„ÄÇ""", []

            # For network errors, wait and retry
            elif "connection" in error_str or "network" in error_str or "timeout" in error_str:
                st.session_state.api_status = "error"
                if attempt < max_retries - 1:
                    logger.info(f"Network error, waiting {retry_delay} seconds before retry...")
                    time.sleep(retry_delay)
                    retry_delay *= 1.5
                    continue
                else:
                    return """üîå **ÁΩëÁªúËøûÊé•ÈóÆÈ¢ò**

ÂæàÊä±Ê≠âÔºåÊó†Ê≥ïËøûÊé•Âà∞AIÊúçÂä°„ÄÇËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÂêéÈáçËØï„ÄÇ

**Âª∫ËÆÆÊ£ÄÊü•Ôºö**
1. ÁΩëÁªúËøûÊé•ÊòØÂê¶Ê≠£Â∏∏
2. Èò≤ÁÅ´Â¢ôËÆæÁΩÆÊòØÂê¶ÈòªÊ≠¢ËøûÊé•
3. APIÊúçÂä°ÊòØÂê¶ÂèØÁî®

ÊÇ®ÁöÑÊ∂àÊÅØÂ∑≤‰øùÂ≠òÔºåÁΩëÁªúÊÅ¢Â§çÂêéÊàëÂèØ‰ª•ÁªßÁª≠ÂØπËØù„ÄÇ""", []

            # For authentication errors, don't retry
            elif "authentication" in error_str or "unauthorized" in error_str or "api key" in error_str:
                st.session_state.api_status = "error"
                return """üîë **APIËÆ§ËØÅÈîôËØØ**

ÂæàÊä±Ê≠âÔºåAPIÂØÜÈí•È™åËØÅÂ§±Ë¥•„ÄÇËØ∑Ê£ÄÊü•ÈÖçÁΩÆÊñá‰ª∂„ÄÇ

**ËØ∑Ê£ÄÊü•Ôºö**
1. MODELSCOPE_API_KEYÊòØÂê¶Ê≠£Á°ÆÈÖçÁΩÆ
2. APIÂØÜÈí•ÊòØÂê¶ÊúâÊïà
3. ÊòØÂê¶ÊúâË∂≥Â§üÁöÑAPIËÆøÈóÆÊùÉÈôê

ËØ∑ËÅîÁ≥ªÁÆ°ÁêÜÂëòÊõ¥Êñ∞APIÈÖçÁΩÆ„ÄÇ""", []

            # For other errors, don't retry
            else:
                st.session_state.api_status = "error"
                return f"""‚ùå **Á≥ªÁªüÈîôËØØ**

ÂæàÊä±Ê≠âÔºåÊàëÈÅáÂà∞‰∫Ü‰∏Ä‰∏™ÊäÄÊúØÈóÆÈ¢òÔºö{str(e)[:100]}...

ËØ∑Á®çÂêéÈáçËØïÔºåÊàñËÅîÁ≥ªÊäÄÊúØÊîØÊåÅ„ÄÇÊÇ®ÁöÑÊ∂àÊÅØÂ∑≤‰øùÂ≠òÔºåÊàë‰∏ç‰ºöÂøòËÆ∞Êàë‰ª¨ÁöÑÂØπËØùÂÜÖÂÆπ„ÄÇ""", []

    # This should not be reached, but just in case
    return "Êä±Ê≠âÔºåÈÅáÂà∞‰∫ÜÊÑèÂ§ñÈîôËØØ„ÄÇËØ∑ÈáçËØï„ÄÇ", []

def process_ai_response():
    """Process AI response asynchronously."""
    if st.session_state.ai_thinking and st.session_state.pending_response:
        try:
            # Get AI response
            user_input, user_id = st.session_state.pending_response

            with st.spinner("ü§ñ Ê≠£Âú®ÊÄùËÄÉ..."):
                response, memories = get_conversation_response(user_input, user_id)

            # Add assistant response to session
            add_message_to_session(
                st.session_state.current_session_id,
                'assistant',
                response,
                memories
            )

            # Clear pending state
            st.session_state.ai_thinking = False
            st.session_state.pending_response = None

            # Rerun to show the response
            st.rerun()

        except Exception as e:
            logger.error(f"Error processing AI response: {e}")
            # Handle error gracefully
            error_response = "Êä±Ê≠âÔºåÂ§ÑÁêÜÊÇ®ÁöÑËØ∑Ê±ÇÊó∂ÈÅáÂà∞‰∫ÜÈóÆÈ¢ò„ÄÇËØ∑Á®çÂêéÈáçËØï„ÄÇ"

            add_message_to_session(
                st.session_state.current_session_id,
                'assistant',
                error_response,
                []
            )

            st.session_state.ai_thinking = False
            st.session_state.pending_response = None
            st.rerun()

def render_sidebar():
    """Render the sidebar with session management."""
    st.sidebar.title("üéõÔ∏è ÊéßÂà∂Èù¢Êùø")

    # Quick stats
    st.sidebar.markdown("### üìä ÂΩìÂâçÁä∂ÊÄÅ")
    current_session = st.session_state.sessions.get(st.session_state.current_session_id, {})
    message_count = len(current_session.get('messages', []))

    st.sidebar.metric("ÂΩìÂâç‰ºöËØùÊ∂àÊÅØ", message_count)
    st.sidebar.metric("ÊÄª‰ºöËØùÊï∞", len(st.session_state.sessions))

    # Quick new session button
    st.sidebar.markdown("---")
    if st.sidebar.button("üöÄ Âø´ÈÄüÊñ∞Âª∫‰ºöËØù", use_container_width=True, help="ÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑÂØπËØù‰ºöËØù"):
        create_new_session()
        st.rerun()

    # API Status indicator
    st.sidebar.markdown("### üì° ÊúçÂä°Áä∂ÊÄÅ")
    if 'api_status' not in st.session_state:
        st.session_state.api_status = "unknown"

    if st.session_state.api_status == "rate_limited":
        st.sidebar.error("üö´ APIÈ¢ëÁéáÈôêÂà∂")
        st.sidebar.caption("ËØ∑Á®çÂêéÈáçËØï")
    elif st.session_state.api_status == "error":
        st.sidebar.warning("‚ö†Ô∏è APIÊúçÂä°ÂºÇÂ∏∏")
        st.sidebar.caption("Ê≠£Âú®Â∞ùËØïÊÅ¢Â§ç...")
    else:
        st.sidebar.success("‚úÖ APIÊúçÂä°Ê≠£Â∏∏")
        st.sidebar.caption("ÈöèÊó∂ÂèØÁî®")

    # User ID input
    st.sidebar.markdown("---")
    st.sidebar.markdown("### üë§ Áî®Êà∑ËÆæÁΩÆ")

    # Prepare user options with better organization
    db_users = set()
    local_users = set()

    # Separate users into database users and locally created users
    if st.session_state.user_history:
        for user in st.session_state.user_history:
            if user != "web_user":
                # Check if user is from database (heuristic: check if it has memories)
                try:
                    memories = search_memories("test", user, limit=1)
                    if memories and memories.get('results'):
                        db_users.add(user)
                    else:
                        local_users.add(user)
                except:
                    local_users.add(user)

    # Create organized user options
    user_options = ["web_user"]

    # Add database users with special indicator
    if db_users:
        user_options.extend([f"üóÑÔ∏è {user}" for user in sorted(db_users)])

    # Add local users
    if local_users:
        user_options.extend([f"üë§ {user}" for user in sorted(local_users)])

    user_options.append("+ ‚ûï Êñ∞Âª∫Áî®Êà∑ID")

    # Find current user index
    current_index = 0
    for i, option in enumerate(user_options):
        # Strip prefixes for comparison
        if option.replace("üóÑÔ∏è ", "").replace("üë§ ", "") == st.session_state.user_id:
            current_index = i
            break

    # User selection dropdown with better formatting
    selected_user = st.sidebar.selectbox(
        "üÜî ÈÄâÊã©Áî®Êà∑ID",
        options=user_options,
        index=current_index,
        help="üóÑÔ∏è = Êï∞ÊçÆÂ∫ìÁî®Êà∑(ÊúâËÆ∞ÂøÜ), üë§ = Êú¨Âú∞Áî®Êà∑, ‰∏çÂêåÁî®Êà∑Êã•ÊúâÁã¨Á´ãÁöÑËÆ∞ÂøÜÁ©∫Èó¥"
    )

    # Handle user selection
    if selected_user == "+ ‚ûï Êñ∞Âª∫Áî®Êà∑ID":
        st.sidebar.markdown("**‚ú® ÂàõÂª∫Êñ∞Áî®Êà∑**")
        new_user_id = st.sidebar.text_input(
            "Êñ∞Áî®Êà∑ID",
            value="",
            placeholder="ËæìÂÖ•Êñ∞ÁöÑÁî®Êà∑ID",
            key="new_user_id_input"
        )
        col1, col2 = st.sidebar.columns([2, 1])
        with col1:
            if st.sidebar.button("üöÄ ÂàõÂª∫", key="create_new_user", use_container_width=True):
                if new_user_id.strip() and new_user_id.strip() not in st.session_state.user_history:
                    st.session_state.user_history.add(new_user_id.strip())
                    st.session_state.user_id = new_user_id.strip()
                    st.sidebar.success(f"‚úÖ Áî®Êà∑ '{new_user_id.strip()}' ÂàõÂª∫ÊàêÂäüÔºÅ")
                    st.rerun()
                elif new_user_id.strip():
                    st.sidebar.warning("‚ö†Ô∏è ËØ•Áî®Êà∑IDÂ∑≤Â≠òÂú®")
        with col2:
            if st.sidebar.button("‚ùå ÂèñÊ∂à", key="cancel_new_user", use_container_width=True):
                st.rerun()
    else:
        # Strip prefixes to get actual user ID
        actual_user_id = selected_user.replace("üóÑÔ∏è ", "").replace("üë§ ", "")

        if actual_user_id != st.session_state.user_id:
            st.session_state.user_id = actual_user_id
            # Add to history if it's not a default user
            if actual_user_id != "web_user":
                st.session_state.user_history.add(actual_user_id)
                # Show user type indicator
                if selected_user.startswith("üóÑÔ∏è"):
                    st.sidebar.success(f"‚úÖ ÂàáÊç¢Âà∞Êï∞ÊçÆÂ∫ìÁî®Êà∑: {actual_user_id}")
                else:
                    st.sidebar.info(f"‚ÑπÔ∏è ÂàáÊç¢Âà∞Êú¨Âú∞Áî®Êà∑: {actual_user_id}")
            st.rerun()

    # User management section with enhanced information
    with st.sidebar.expander("üë• Áî®Êà∑ÁÆ°ÁêÜ", expanded=False):
        st.sidebar.markdown("#### üìä Áî®Êà∑ÁªüËÆ°")

        # User statistics
        total_users = len(st.session_state.user_history)
        current_user = st.session_state.user_id

        st.sidebar.metric("üî¢ ÊÄªÁî®Êà∑Êï∞", total_users)
        st.sidebar.metric("üÜî ÂΩìÂâçÁî®Êà∑", current_user)

        st.sidebar.markdown("#### üìã Áî®Êà∑ËØ¶ÊÉÖ")

        if st.session_state.user_history:
            # Categorize users
            db_users_list = []
            local_users_list = []

            for user in sorted(list(st.session_state.user_history)):
                try:
                    memories = search_memories("test", user, limit=1)
                    if memories and memories.get('results'):
                        db_users_list.append(user)
                    else:
                        local_users_list.append(user)
                except:
                    local_users_list.append(user)

            # Display database users with statistics
            if db_users_list:
                st.sidebar.markdown("**üóÑÔ∏è Êï∞ÊçÆÂ∫ìÁî®Êà∑ (ÊúâËÆ∞ÂøÜ):**")
                for user in db_users_list:
                    # Get user statistics
                    stats = get_user_statistics(user)

                    with st.sidebar.container():
                        col1, col2, col3, col4 = st.sidebar.columns([2, 1, 1, 1])
                        with col1:
                            is_current = "üü¢" if user == current_user else "‚ö™"
                            st.sidebar.write(f"{is_current} **{user}**")
                        with col2:
                            st.sidebar.write(f"üìö {stats['memory_count']}")
                        with col3:
                            if stats['last_activity']:
                                try:
                                    from datetime import datetime
                                    if isinstance(stats['last_activity'], str):
                                        last_dt = datetime.fromisoformat(stats['last_activity'].replace('Z', '+00:00'))
                                    else:
                                        last_dt = datetime.fromtimestamp(stats['last_activity'])
                                    st.sidebar.write(f"üïí {last_dt.strftime('%m/%d')}")
                                except:
                                    st.sidebar.write("üïí ÊúÄËøë")
                            else:
                                st.sidebar.write("üïí Êú™Áü•")
                        with col4:
                            if st.sidebar.button("üóëÔ∏è", key=f"delete_user_{user}", help="Âà†Èô§Áî®Êà∑"):
                                if user in st.session_state.user_history:
                                    st.session_state.user_history.remove(user)
                                    if user == current_user:
                                        st.session_state.user_id = "web_user"
                                    st.rerun()

            # Display local users
            if local_users_list:
                st.sidebar.markdown("**üë§ Êú¨Âú∞Áî®Êà∑ (Êó†ËÆ∞ÂøÜ):**")
                for user in local_users_list:
                    with st.sidebar.container():
                        col1, col2, col3 = st.sidebar.columns([3, 1, 1])
                        with col1:
                            is_current = "üü¢" if user == current_user else "‚ö™"
                            st.sidebar.write(f"{is_current} {user}")
                        with col2:
                            st.sidebar.write("üîß")
                        with col3:
                            if st.sidebar.button("üóëÔ∏è", key=f"delete_local_user_{user}", help="Âà†Èô§Áî®Êà∑"):
                                if user in st.session_state.user_history:
                                    st.session_state.user_history.remove(user)
                                    if user == current_user:
                                        st.session_state.user_id = "web_user"
                                    st.rerun()
        else:
            st.sidebar.info("üìù ÊöÇÊó†ÂéÜÂè≤Áî®Êà∑")

    # Advanced session management section
    with st.sidebar.expander("üõ†Ô∏è ‰ºöËØùÁÆ°ÁêÜ (È´òÁ∫ß)", expanded=False):
        st.sidebar.info("üí° **ÊèêÁ§∫**: ÊÇ®ÂèØ‰ª•ÂàõÂª∫Â§ö‰∏™‰ºöËØùÊù•ÁªÑÁªá‰∏çÂêå‰∏ªÈ¢òÁöÑÂØπËØù")

        # New session creation
        with st.sidebar.expander("‚ûï Êñ∞Âª∫‰ºöËØù", expanded=False):
            session_name = st.sidebar.text_input(
                "‰ºöËØùÂêçÁß∞",
                value="",
                key="new_session_name",
                placeholder="ÁïôÁ©∫‰ΩøÁî®ÈªòËÆ§ÂêçÁß∞"
            )
            col1, col2 = st.sidebar.columns(2)
            with col1:
                if st.sidebar.button("ÂàõÂª∫‰ºöËØù", use_container_width=True, key="create_custom_session"):
                    create_new_session(session_name if session_name.strip() else None)
                    st.rerun()
            with col2:
                if st.sidebar.button("Âø´ÈÄüÂàõÂª∫", use_container_width=True, key="create_default_session"):
                    create_new_session()
                    st.rerun()

        # Session list
        st.sidebar.markdown("#### üìö ‰ºöËØùÂàóË°®")

        if st.session_state.sessions:
            for session_id, session_data in st.session_state.sessions.items():
                with st.sidebar.container():
                    col1, col2 = st.columns([4, 1])

                    with col1:
                        session_name = session_data['name']
                        last_updated = datetime.fromisoformat(session_data['last_updated'])
                        time_str = last_updated.strftime("%m/%d %H:%M")
                        msg_count = len(session_data.get('messages', []))

                        # Show active indicator and message count
                        indicator = "üü¢" if session_id == st.session_state.current_session_id else "‚ö™"

                        if st.button(
                            f"{indicator} **{session_name}**\n*{time_str}* | {msg_count}Êù°Ê∂àÊÅØ",
                            key=f"session_{session_id}",
                            use_container_width=True,
                            help=f"ÁÇπÂáªÂàáÊç¢Âà∞Ê≠§‰ºöËØù ({msg_count}Êù°Ê∂àÊÅØ)"
                        ):
                            switch_session(session_id)
                            st.rerun()

                    with col2:
                        if st.button("üóëÔ∏è", key=f"delete_{session_id}", help="Âà†Èô§‰ºöËØù"):
                            delete_session(session_id)
                            st.rerun()

        else:
            st.sidebar.info("ÊöÇÊó†‰ºöËØù")

    # Memory management info
    st.sidebar.markdown("---")
    st.sidebar.markdown("### üß† ËÆ∞ÂøÜÂäüËÉΩ")
    st.sidebar.success("""
    ‚úÖ **Ë∑®‰ºöËØùËÆ∞ÂøÜÂ∑≤ÂêØÁî®**
    - Ëá™Âä®‰øùÂ≠òÂØπËØùÂéÜÂè≤
    - Êô∫ËÉΩ‰∏ä‰∏ãÊñáÊ£ÄÁ¥¢
    - Áî®Êà∑Êï∞ÊçÆÈöîÁ¶ª
    """)

    # Help section
    with st.sidebar.expander("‚ùì ‰ΩøÁî®Â∏ÆÂä©", expanded=False):
        st.sidebar.markdown("""
        **Âü∫Êú¨Êìç‰Ωú:**
        - Áõ¥Êé•Âú®ËæìÂÖ•Ê°ÜËÅäÂ§©
        - ÁÇπÂáªÂª∫ËÆÆÊåâÈíÆÂø´ÈÄüÂºÄÂßã

        **È´òÁ∫ßÂäüËÉΩ:**
        - ÂàõÂª∫Â§ö‰∏™Áã¨Á´ã‰ºöËØù
        - Ëá™ÂÆö‰πâÁî®Êà∑IDÈöîÁ¶ªËÆ∞ÂøÜ
        - Êü•ÁúãAIÂõûÂ§çÁöÑËÆ∞ÂøÜÂºïÁî®

        **ËÆ∞ÂøÜÂäüËÉΩ:**
        - AI‰ºöËá™Âä®ËÆ∞‰ΩèÈáçË¶Å‰ø°ÊÅØ
        - Ë∑®‰ºöËØù‰øùÊåÅËøûÁª≠ÂØπËØù
        - ÊîØÊåÅ‰∏™ÊÄßÂåñÂõûÂ∫î
        """)

def render_memory_details(memories: List[Dict], message_key: str):
    """Render memory details in an expandable section."""
    if not memories:
        return

    # Toggle button for memory details
    if st.button("üß† ÂøÜËØ≠ÂºïÁî®", key=f"memory_toggle_{message_key}"):
        st.session_state.show_memory_details[message_key] = not st.session_state.show_memory_details.get(message_key, False)

    # Show expanded memory details
    if st.session_state.show_memory_details.get(message_key, False):
        with st.expander("üß† ÂøÜËØ≠ËÆ∞ÂøÜËØ¶ÊÉÖ", expanded=True):
            for i, memory in enumerate(memories, 1):
                memory_text = memory.get('memory', '')
                score = memory.get('score', 0)

                st.markdown(f"""
                <div class="memory-ref">
                    <strong>ÂøÜËØ≠ËÆ∞ÂøÜ {i} (Áõ∏‰ººÂ∫¶: {score:.3f}):</strong><br>
                    {memory_text}
                </div>
                """, unsafe_allow_html=True)

def render_chat_interface():
    """Render the main chat interface."""
    st.title("üß†üí¨ ÂøÜËØ≠ (YiYu) - Êô∫ËÉΩÂØπËØùÔºåËÆ∞ÂøÜÊ∞∏Â≠ò")

    # Ensure we have an active session (should always be true now)
    if not st.session_state.current_session_id:
        st.error("‚ùå ‰ºöËØùÈîôËØØÔºåËØ∑Âà∑Êñ∞È°µÈù¢ÈáçËØï")
        return

    current_session = st.session_state.sessions[st.session_state.current_session_id]

    # Display session name with edit option
    if 'editing_session_name' not in st.session_state:
        st.session_state.editing_session_name = False

    col1, col2 = st.columns([4, 1])

    if not st.session_state.editing_session_name:
        with col1:
            st.markdown(f"### üìù {current_session['name']}")
        with col2:
            if st.button("‚úèÔ∏è", key="rename_session", help="ÈáçÂëΩÂêç‰ºöËØù"):
                st.session_state.editing_session_name = True
                st.session_state.temp_session_name = current_session['name']
                st.rerun()
    else:
        with col1:
            new_name = st.text_input(
                "Êñ∞‰ºöËØùÂêçÁß∞",
                value=st.session_state.get('temp_session_name', current_session['name']),
                key="session_rename_input",
                label_visibility="collapsed"
            )
        with col2:
            col_save, col_cancel = st.columns(2)
            with col_save:
                if st.button("‚úÖ", key="confirm_rename", help="‰øùÂ≠òÂêçÁß∞"):
                    if new_name.strip():
                        current_session['name'] = new_name.strip()
                        st.session_state.editing_session_name = False
                        if 'temp_session_name' in st.session_state:
                            del st.session_state.temp_session_name
                        st.rerun()
            with col_cancel:
                if st.button("‚ùå", key="cancel_rename", help="ÂèñÊ∂àÁºñËæë"):
                    st.session_state.editing_session_name = False
                    if 'temp_session_name' in st.session_state:
                        del st.session_state.temp_session_name
                    st.rerun()

    # Show welcome message for first-time users or empty sessions
    if st.session_state.first_visit and not current_session['messages']:
        st.markdown("""
        <div style='background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white; padding: 1.5rem; border-radius: 1rem; margin-bottom: 1rem;'>
            <h3>üëã Ê¨¢Ëøé‰ΩøÁî®ÂøÜËØ≠ (YiYu)ÔºÅ</h3>
            <p>ÊàëÊòØÊÇ®ÁöÑÊô∫ËÉΩÂØπËØù‰ºô‰º¥ÔºåÂÖ∑ÊúâË∑®‰ºöËØùËÆ∞ÂøÜÂäüËÉΩ„ÄÇÂøÜËØ≠ÂèØ‰ª•Ôºö</p>
            <ul>
                <li>üß† ËÆ∞‰ΩèÊàë‰ª¨ÁöÑÂØπËØùÂéÜÂè≤</li>
                <li>üéØ Êèê‰æõ‰∏™ÊÄßÂåñÁöÑÂõûÂ∫î</li>
                <li>üìö ÊîØÊåÅÂ§ö‰∏™Áã¨Á´ã‰ºöËØù</li>
            </ul>
            <p><strong>Áé∞Âú®Â∞±ÂºÄÂßãÂØπËØùÂêßÔºÅ</strong> üöÄ</p>
        </div>
        """, unsafe_allow_html=True)
        st.session_state.first_visit = False

    # Chat messages container
    chat_container = st.container()

    with chat_container:
        # Display conversation history
        messages = current_session['messages']

        for i, msg in enumerate(messages):
            if msg['role'] == 'user':
                message(msg['content'], is_user=True, key=f"user_{i}")
            else:
                message(msg['content'], is_user=False, key=f"assistant_{i}")

                # Show memory details for assistant messages
                if msg.get('memories'):
                    render_memory_details(msg['memories'], f"msg_{i}")

        # Show AI thinking indicator
        if st.session_state.ai_thinking:
            st.markdown("""
            <div style='text-align: center; padding: 1rem; color: #666;'>
                <div class="thinking-indicator">
                    ü§ñ Ê≠£Âú®ÊÄùËÄÉ‰∏≠...
                </div>
            </div>
            """, unsafe_allow_html=True)

    # Process AI response if pending
    if st.session_state.ai_thinking and st.session_state.pending_response:
        process_ai_response()

    # User input at the bottom
    st.markdown("---")

    # Enhanced input form
    with st.form(key="user_input_form", clear_on_submit=True):
        col1, col2 = st.columns([5, 1])

        with col1:
            # Get quick suggestion if available
            default_value = ""
            input_key = "user_message"

            if 'quick_suggestion' in st.session_state:
                default_value = st.session_state.quick_suggestion
                # ‰ΩøÁî®Êó∂Èó¥Êà≥Á°Æ‰øùÊØèÊ¨°ÂºïÂØºËØ≠ÂèòÂåñÊó∂ÈÉΩÂàõÂª∫Êñ∞ÁöÑËæìÂÖ•Ê°Ü
                if 'suggestion_timestamp' not in st.session_state:
                    st.session_state.suggestion_timestamp = 0
                input_key = f"user_message_{st.session_state.suggestion_timestamp}"

            user_input = st.text_input(
                "üí¨ ÂíåÊàëËÅäËÅäÂêß:",
                value=default_value,
                placeholder="ËæìÂÖ•ÊÇ®ÊÉ≥ËØ¥ÁöÑËØùÔºåÊØîÂ¶ÇÔºö‰Ω†Â•ΩÔºåÊàëÊÉ≥‰∫ÜËß£‰∏Ä‰∏ã‰Ω†ÁöÑÂäüËÉΩ...",
                key=input_key,
                label_visibility="collapsed"
            )

        with col2:
            submit_button = st.form_submit_button("ÂèëÈÄÅ üöÄ", use_container_width=True)

    # Quick suggestions for new users
    if st.session_state.show_suggestions:
        st.markdown("**üí° ËØïËØïËøô‰∫õÈóÆÈ¢òÔºö**")

        # ‰∏™‰∫∫‰ø°ÊÅØÁ±ªÈóÆÈ¢ò
        st.markdown("**üë§ ‰∏™‰∫∫‰ø°ÊÅØËÆæÁΩÆ**")
        personal_col1, personal_col2, personal_col3 = st.columns(3)
        with personal_col1:
            if st.button("üìù ÊàëÁöÑÂßìÂêçÊòØ", key="suggestion_name", use_container_width=True):
                import time
                st.session_state.quick_suggestion = "ÊàëÁöÑÂßìÂêçÊòØ"
                st.session_state.suggestion_timestamp = int(time.time() * 1000)
                st.session_state.show_suggestions = False
                st.rerun()
        with personal_col2:
            if st.button("‚úàÔ∏è ÊàëÂñúÊ¨¢Âéª...ÊóÖË°å", key="suggestion_travel", use_container_width=True):
                import time
                st.session_state.quick_suggestion = "ÊàëÂñúÊ¨¢Âéª...ÊóÖË°å"
                st.session_state.suggestion_timestamp = int(time.time() * 1000)
                st.session_state.show_suggestions = False
                st.rerun()
        with personal_col3:
            if st.button("üçΩÔ∏è ÊàëÂñúÊ¨¢ÂìÅÂ∞ù", key="suggestion_food", use_container_width=True):
                import time
                st.session_state.quick_suggestion = "ÊàëÂñúÊ¨¢ÂìÅÂ∞ù"
                st.session_state.suggestion_timestamp = int(time.time() * 1000)
                st.session_state.show_suggestions = False
                st.rerun()

        personal_col4, personal_col5, personal_col6 = st.columns(3)
        with personal_col4:
            if st.button("‚ö†Ô∏è ÊàëÂØπ...ËøáÊïè", key="suggestion_allergy", use_container_width=True):
                import time
                st.session_state.quick_suggestion = "ÊàëÂØπ...ËøáÊïè"
                st.session_state.suggestion_timestamp = int(time.time() * 1000)
                st.session_state.show_suggestions = False
                st.rerun()
        with personal_col5:
            if st.button("üíº ÊàëÊ≠£Âú®‰ªé‰∫ã", key="suggestion_work", use_container_width=True):
                import time
                st.session_state.quick_suggestion = "ÊàëÊ≠£Âú®‰ªé‰∫ã"
                st.session_state.suggestion_timestamp = int(time.time() * 1000)
                st.session_state.show_suggestions = False
                st.rerun()
        with personal_col6:
            if st.button("üéØ Êõ¥Â§ö‰ø°ÊÅØ", key="suggestion_more_info", use_container_width=True):
                import time
                st.session_state.quick_suggestion = "ÊàëÊÉ≥Ê∑ªÂä†Êõ¥Â§ö‰∏™‰∫∫‰ø°ÊÅØ"
                st.session_state.suggestion_timestamp = int(time.time() * 1000)
                st.session_state.show_suggestions = False
                st.rerun()

        st.markdown("---")  # ÂàÜÈöîÁ∫ø

        # Á≥ªÁªüÂäüËÉΩÁ±ªÈóÆÈ¢ò
        st.markdown("**ü§ñ Á≥ªÁªüÂäüËÉΩ‰∫ÜËß£**")
        system_col1, system_col2, system_col3 = st.columns(3)
        with system_col1:
            if st.button("üëã Ëá™Êàë‰ªãÁªç", key="suggestion_intro", use_container_width=True):
                import time
                st.session_state.quick_suggestion = "‰Ω†Â•ΩÔºåËØ∑‰ªãÁªç‰∏Ä‰∏ã‰Ω†Ëá™Â∑±"
                st.session_state.suggestion_timestamp = int(time.time() * 1000)
                st.session_state.show_suggestions = False
                st.rerun()
        with system_col2:
            if st.button("üß† ËÆ∞ÂøÜÂäüËÉΩ", key="suggestion_memory", use_container_width=True):
                import time
                st.session_state.quick_suggestion = "‰Ω†ÁöÑËÆ∞ÂøÜÂäüËÉΩÊòØÊÄé‰πàÂ∑•‰ΩúÁöÑÔºü"
                st.session_state.suggestion_timestamp = int(time.time() * 1000)
                st.session_state.show_suggestions = False
                st.rerun()
        with system_col3:
            if st.button("üéØ ÂäüËÉΩÁâπËâ≤", key="suggestion_features", use_container_width=True):
                import time
                st.session_state.quick_suggestion = "‰Ω†Êúâ‰ªÄ‰πàÁâπÂà´ÁöÑÂäüËÉΩÂêóÔºü"
                st.session_state.suggestion_timestamp = int(time.time() * 1000)
                st.session_state.show_suggestions = False
                st.rerun()

    # Show selected suggestion preview
    if st.session_state.selected_suggestion and st.session_state.suggestion_source == "button":
        st.markdown("---")
        st.markdown("### üìù ÈÄâ‰∏≠ÁöÑÂºïÂØºËØ≠")

        # Display the selected suggestion in a nice container
        st.markdown(f"""
        <div style='background-color: #E3F2FD; padding: 1rem; border-radius: 0.5rem; border-left: 4px solid #2196F3;'>
            <strong>üí° Âª∫ËÆÆÈóÆÈ¢ò:</strong><br>
            {st.session_state.selected_suggestion}
        </div>
        """, unsafe_allow_html=True)

        # Action buttons
        col1, col2, col3 = st.columns([1, 1, 1])
        with col1:
            if st.button("üöÄ ÂèëÈÄÅËøô‰∏™ÈóÆÈ¢ò", key="send_suggestion", use_container_width=True):
                # Directly process the suggestion as user input
                suggestion_text = st.session_state.selected_suggestion

                # Check for rate limiting cooldown
                import time
                current_time = time.time()

                if (st.session_state.api_status == "rate_limited" and
                    current_time - st.session_state.get('last_api_check', 0) < 120):
                    st.warning("‚è∞ APIÈ¢ëÁéáÈôêÂà∂‰∏≠ÔºåËØ∑Á≠âÂæÖ2ÂàÜÈíüÂêéÂÜçËØï")
                    st.stop()

                # Hide suggestions and clear selected suggestion
                st.session_state.show_suggestions = False
                st.session_state.selected_suggestion = None
                st.session_state.suggestion_source = None

                # Add user message to session immediately
                add_message_to_session(
                    st.session_state.current_session_id,
                    'user',
                    suggestion_text
                )

                # Set AI processing state
                st.session_state.ai_thinking = True
                st.session_state.pending_response = (suggestion_text, st.session_state.user_id)

                # Rerun to show user message immediately
                st.rerun()

        with col2:
            if st.button("‚úèÔ∏è ‰øÆÊîπÈóÆÈ¢ò", key="edit_suggestion", use_container_width=True):
                st.session_state.quick_suggestion = st.session_state.selected_suggestion
                st.session_state.selected_suggestion = None
                st.session_state.suggestion_source = None
                st.rerun()
        with col3:
            if st.button("‚ùå ÂèñÊ∂à", key="cancel_suggestion", use_container_width=True):
                st.session_state.selected_suggestion = None
                st.session_state.suggestion_source = None
                st.rerun()

        st.markdown("---")

    # Clear quick suggestion after it's been used
    if 'quick_suggestion' in st.session_state and submit_button:
        del st.session_state.quick_suggestion

    # Handle user input
    if submit_button and user_input.strip():
        # Check for rate limiting cooldown
        import time
        current_time = time.time()

        if (st.session_state.api_status == "rate_limited" and
            current_time - st.session_state.get('last_api_check', 0) < 120):
            st.warning("‚è∞ APIÈ¢ëÁéáÈôêÂà∂‰∏≠ÔºåËØ∑Á≠âÂæÖ2ÂàÜÈíüÂêéÂÜçËØï")
            st.stop()

        # Hide suggestions and clear selected suggestion after first message
        st.session_state.show_suggestions = False
        st.session_state.selected_suggestion = None
        st.session_state.suggestion_source = None

        # Add user message to session immediately
        add_message_to_session(
            st.session_state.current_session_id,
            'user',
            user_input.strip()
        )

        # Set AI processing state
        st.session_state.ai_thinking = True
        st.session_state.pending_response = (user_input.strip(), st.session_state.user_id)

        # Rerun to show user message immediately
        st.rerun()

def main():
    """Main application entry point."""
    init_session_state()

    # Render sidebar
    render_sidebar()

    # Render main chat interface
    render_chat_interface()

    # Footer
    st.markdown("---")
    st.markdown(
        """
        <div style='text-align: center; color: #666; font-size: 0.8em;'>
            ÂøÜËØ≠ (YiYu) - Âü∫‰∫éLangGraphÂíåMem0ÁöÑÊô∫ËÉΩÂØπËØùËÆ∞ÂøÜÁ≥ªÁªü |
            ÊîØÊåÅË∑®‰ºöËØùËÆ∞ÂøÜ | Êú¨Âú∞ÂêëÈáèÊï∞ÊçÆÂ∫ì
        </div>
        """,
        unsafe_allow_html=True
    )

if __name__ == "__main__":
    main()